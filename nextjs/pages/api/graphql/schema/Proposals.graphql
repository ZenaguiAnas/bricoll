# ! all the types may change in the future
# the project could be one of the following

enum proposal_status {
  canceled
  declined
  in_progress
  approved
}
# the proposal could be one of the following
type Proposal {
  _id: ObjectID #auto generated
  project_id: ObjectID!
  freelancer_id: ObjectID!
  price: Float!
  duration: Int!
  description: String!
  cover_letter: String!
  created_at: Date!
  updated_at: Date!
  status: proposal_status!
  # current time
  attachmentsURL: [Attachment]
  # the link of urls of the attachments(files, images, video)
}

# Cover Letter, Attachments (images +video +files ...)

type Query {
  Proposal(id: ObjectID!): Proposal
  # by the freelancer | client
  ProposalsByFreelancer(freelancer_id: ObjectID!): [Proposal]
  # on the freelancer
  ProposalsByProject(project_id: ObjectID!): [Proposal]
  # on the client(project owner)
}

type Mutation {
  submitProposal(
    project_id: ObjectID!
    price: Float! @constraint(min: 1, max: 10000)
    duration: Int! @constraint(exclusiveMin: 0, exclusiveMax: 90)
    description: String! @constraint(minLength: 5, maxLength: 1000)
    cover_letter: String! @constraint(minLength: 5, maxLength: 1000)
    attachmentsURL: [AttachmentInput]
  ): Proposal!
  editProposal(
    id: ObjectID!
    price: Float! @constraint(min: 1, max: 10000)
    duration: Int! @constraint(exclusiveMin: 0, exclusiveMax: 90)
    description: String! @constraint(minLength: 5, maxLength: 1000)
  ): Proposal
  declineProposal(id: ObjectID!): Proposal
  # by the client
  withdrawProposal(id: ObjectID!): Proposal
  # by the freelancer
  acceptProposal(id: ObjectID!): Proposal
  # by the client
  # todo
  # open_chat_room(id: ObjectID!): Proposal
  # by the freelancer and the client
  # acceptTerms(id: ObjectID!): Proposal
  #by the freelancer and the client
}

type Subscription {
  proposalStatusChanged(id: ObjectID!): Proposal
  # when the status of the proposal changed
  projectGotProposal(id: ObjectID!): Proposal
  # when the project got a new proposal
}
